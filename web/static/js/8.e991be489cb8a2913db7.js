webpackJsonp([8],{IZ0a:function(a,s){},X3tQ:function(a,s,t){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var e={render:function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("div",{staticClass:"no-bg"},[t("el-row",{attrs:{gutter:20}},[t("el-col",{attrs:{span:8}},[t("div",{staticClass:"panel"},[t("div",{staticClass:"panel-heading"},[a._v("\n          透明方格\n        ")]),a._v(" "),t("div",{staticClass:"panel-body"},[t("div",{staticClass:"square square1"})])])]),a._v(" "),t("el-col",{attrs:{span:8}},[t("div",{staticClass:"panel"},[t("div",{staticClass:"panel-heading"},[a._v("\n          网格\n        ")]),a._v(" "),t("div",{staticClass:"panel-body"},[t("div",{staticClass:"square square2"})])])]),a._v(" "),t("el-col",{attrs:{span:8}},[t("div",{staticClass:"panel"},[t("div",{staticClass:"panel-heading"},[a._v("\n          平行四边形\n        ")]),a._v(" "),t("div",{staticClass:"panel-body"},[t("div",{staticClass:"square square3"},[t("div",{staticClass:"shape-left"}),a._v(" "),t("div",{staticClass:"shape-right"}),a._v(" "),t("div",{staticClass:"article"},[a._v("\n              如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的服务端渲染。\n              服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。\n            ")])])])])])],1)],1)},staticRenderFns:[]};var i=t("VU/8")(null,e,!1,function(a){t("IZ0a")},"data-v-97f5b8d0",null);s.default=i.exports}});
//# sourceMappingURL=8.e991be489cb8a2913db7.js.map